"""Chat Service with Multi-Agent System (Enhanced)"""
from typing import List, Dict, Optional
from datetime import datetime, timezone
from sqlalchemy.orm import Session

from models import Conversation, Message, Character, GeneratedImage
from image_service import image_service
from prompt_builder import extract_character_dict
from config import settings
from agents.agent_system import AgentSystem


class AgentChatService:
    """Chat service powered by multi-agent system"""

    def __init__(self):
        self.context_window = settings.CONTEXT_WINDOW
        # Initialize the agent system
        self.agent_system = AgentSystem(api_key=settings.HF_API_TOKEN)
        print(f"[AgentChatService] Initialized with agents: {self.agent_system.get_agent_status()}")

    async def send_message(
        self,
        db: Session,
        character_id: int,
        user_message: str,
        conversation_id: Optional[int] = None
    ) -> dict:
        """Send a message using the multi-agent system"""

        # 1. Get the character
        character = db.query(Character).filter(Character.id == character_id).first()
        if not character:
            raise ValueError("Character not found")

        # 2. Get or create conversation
        if conversation_id:
            conversation = db.query(Conversation).filter(
                Conversation.id == conversation_id,
                Conversation.character_id == character_id
            ).first()
            if not conversation:
                raise ValueError("Conversation not found")
        else:
            # New conversation
            conversation = Conversation(
                character_id=character_id,
                title=user_message[:50] + "..." if len(user_message) > 50 else user_message
            )
            db.add(conversation)
            db.commit()
            db.refresh(conversation)

            # Add greeting as first message if defined
            if character.greeting:
                greeting_msg = Message(
                    conversation_id=conversation.id,
                    role="assistant",
                    content=character.greeting
                )
                db.add(greeting_msg)
                db.commit()

        # 3. Load conversation history
        history = self._load_context(db, conversation.id, self.context_window)

        # 4. Convert character to dict
        char_dict = extract_character_dict(character)

        # 5. Process through multi-agent system
        agent_result = await self.agent_system.process_message(
            message=user_message,
            character=char_dict,
            conversation_history=history,
            character_id=character_id
        )

        response_text = agent_result["response"]
        image_url = None

        # 6. Generate image if requested by agents
        if agent_result["generate_image"] and agent_result["image_prompt"]:
            try:
                # Use the prompt generated by the Image Agent
                prompt = agent_result["image_prompt"]
                is_nsfw = agent_result["image_nsfw"]
                # Get NSFW level from multi-agent system (AUTHORITATIVE source)
                nsfw_level = agent_result.get("image_nsfw_level", agent_result.get("intent", {}).get("nsfw_level", 0))

                # DEBUG: Log the prompt being sent
                print(f"\n{'='*60}")
                print(f"[AgentChatService] IMAGE GENERATION DEBUG")
                print(f"[AgentChatService] User message: {user_message}")
                print(f"[AgentChatService] NSFW level: {nsfw_level}")
                print(f"[AgentChatService] Is NSFW: {is_nsfw}")
                print(f"[AgentChatService] PROMPT: {prompt}")
                print(f"{'='*60}\n")

                # Get consistent seed for character
                character_seed = image_service.get_character_seed(character_id)

                filename = await image_service.generate(
                    prompt=prompt,
                    style=character.style or "realistic",
                    seed=character_seed,
                    nsfw=is_nsfw,
                    nsfw_level=nsfw_level
                )
                image_url = f"/api/images/{filename}"

                # Save to gallery
                gen_image = GeneratedImage(
                    character_id=character_id,
                    conversation_id=conversation.id,
                    prompt=prompt,
                    image_path=filename
                )
                db.add(gen_image)

            except Exception as e:
                print(f"[AgentChatService] Image generation error: {e}")

        # 7. Save messages to database
        user_msg = Message(
            conversation_id=conversation.id,
            role="user",
            content=user_message
        )
        db.add(user_msg)

        assistant_msg = Message(
            conversation_id=conversation.id,
            role="assistant",
            content=response_text,
            image_url=image_url
        )
        db.add(assistant_msg)

        # Update conversation timestamp
        conversation.updated_at = datetime.now(timezone.utc)

        db.commit()
        db.refresh(assistant_msg)

        return {
            "response": response_text,
            "image_url": image_url,
            "conversation_id": conversation.id,
            "message_id": assistant_msg.id,
            "intent": agent_result.get("intent", {})
        }

    def _load_context(self, db: Session, conversation_id: int, limit: int) -> List[Dict]:
        """Load last N messages from a conversation"""
        messages = db.query(Message).filter(
            Message.conversation_id == conversation_id
        ).order_by(
            Message.created_at.desc()
        ).limit(limit).all()

        # Reverse for chronological order
        messages = list(reversed(messages))

        return [
            {"role": msg.role, "content": msg.content}
            for msg in messages
        ]

    def get_conversation_history(self, db: Session, conversation_id: int) -> Optional[dict]:
        """Get full conversation history"""
        conversation = db.query(Conversation).filter(
            Conversation.id == conversation_id
        ).first()

        if not conversation:
            return None

        messages = db.query(Message).filter(
            Message.conversation_id == conversation_id
        ).order_by(Message.created_at.asc()).all()

        return {
            "conversation_id": conversation.id,
            "character_id": conversation.character_id,
            "title": conversation.title,
            "created_at": conversation.created_at.isoformat(),
            "messages": [
                {
                    "id": msg.id,
                    "role": msg.role,
                    "content": msg.content,
                    "image_url": msg.image_url,
                    "created_at": msg.created_at.isoformat()
                }
                for msg in messages
            ]
        }

    def list_conversations(self, db: Session, character_id: int) -> List[dict]:
        """List all conversations for a character"""
        conversations = db.query(Conversation).filter(
            Conversation.character_id == character_id
        ).order_by(Conversation.updated_at.desc()).all()

        return [
            {
                "id": conv.id,
                "character_id": conv.character_id,
                "title": conv.title,
                "created_at": conv.created_at.isoformat(),
                "updated_at": conv.updated_at.isoformat(),
                "last_message": self._get_last_message(db, conv.id)
            }
            for conv in conversations
        ]

    def _get_last_message(self, db: Session, conversation_id: int) -> Optional[str]:
        """Get the last message from a conversation"""
        msg = db.query(Message).filter(
            Message.conversation_id == conversation_id
        ).order_by(Message.created_at.desc()).first()

        if msg:
            content = msg.content[:100] + "..." if len(msg.content) > 100 else msg.content
            return content
        return None


# Global instance - will be used when USE_AGENTS=true
agent_chat_service = AgentChatService()
